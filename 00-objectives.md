# Objectives

The protocol specifications below detail how participants using a multisignature can effectively use state channels to install, update, and uninstall arbitrary off-chain applications.

## Table of Contents

- [Design Goals](#design-goals)
- [Structure](#structure)

## Design Goals

### One round trip communication

The protocol has been optimized to require the minimum number of round trips possible for secure updates to the off-chain state. This has effectively led to the use of multiple transactions being bundled inside a single transaction using the [`MultiSend`](https://github.com/counterfactual/monorepo/blob/master/packages/contracts/contracts/delegateTargets/MultiSend.sol) contract built by Gnosis.

The goal of having one round trip for each protocol execution is purely an optimization and it is the case that "uncompressed" variations do exist that are equally as secure but more costly in communication overhead. This is [currently up for discussion](https://github.com/counterfactual/specs/issues/13).

### Constant sized communication

The aim of the protocol is to execute without any variability in any of:

- Total number of active off-chain applications
- Total number of inactive off-chain applications
- Total number of sequential state updates to an application

That is to say, the design aims for **parallelizability** in general, ensuring that historical use of the protocol has a constant factor implication with regards to size of messages being transmitted on future use of the protocol.

### O(1) response to griefing attacks

It is possible to arrive at a state where any stale-state-griefing attack can be responded to with a single transaction of constant size, in particular, independent of number of active or historical apps. This goal is to ensure that any kind of inevitable griefing vectors that are impossible to fully disqualify off-chain are resolvable with the minimum amount of cost to the person being griefed on-chain.

## Structure

A protocol consists of the following components:

- **Exchange**. The protocol exchange is the series of messages exchanged between all parties in the state channel, as well as dependencies between messages.

- **Message**. A message is the set of information that must be exchanged by the parties to recreate and validate the commitment signatures and associated transactions that those signatures enable. Each protocol may in general contain multiple message types.

- **Commitments**. A protocol produces one or more commitments. Both the signatures and the data contained within the commitments must be stored.

> Note: Messages are represented as JSON-encoded objects; the transport layer should be able to reliably send and receive such messages.

> Note: Some data required for signature verification is _not_ present in these messages but is deterministically generated by each party. For example, [`setNonce`](https://github.com/counterfactual/monorepo/blob/master/packages/contracts/contracts/NonceRegistry.sol#L42) requires a salt, which is a monotonically increasing counter on the number of applications in a channel.

### Commitment Structure

- **Signature**. The resultant data generated by computing a cryptographic signature over some hash representing the transaction to be executed.

- **Data**. Supplementary data that that allows any party in the protocol to reconstruct the hash and thus verify the signature.

- **Transaction Digest**. The transaction digest is the hash that is signed by each party, enabling the protocol's transaction to be executed on-chain. The calldata, if present, is used to generate the digest.

- **Transaction**. The transaction is the `(to, val, data, op)` tuple that a given protocol allows one to broadcast on-chain. These transactions enforce commitments created from the calldata and signature digests, manifesting the off-chain counterfactual state into the on-chain reality.
