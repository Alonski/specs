![](https://img.shields.io/badge/status-wip-orange.svg?style=flat-square) Counterfactual Protocols
====================================================================================================

Authors:

- [Armani Ferrante](https://github.com/armaniferrante)
- [Xuanji Li](https://github.com/ldct)

Reviewers:

- [Liam Horne](https://github.com/snario)

* * *

## Protocols

A protocol is a series of actions performed by participants that change the state of a GSC. The list of protocols is: setup, install, update, uninstall.

A protocol consists of the following:

- **Handshake**. The protocol handshake is the series of messages exchanged between all parties in the state channel, as well as dependencies between messages. We write the handshake in a table; each message depends on the rows above it (i.e., the sender will not send the message until all the above messages have been sent/received), and each column represents the sender of the message.
- **Message**. A message is the set of information that must be exchanged by the parties to recreate (and validate) the commitment signatures and associated transactions that those signatures enable. Each protocol may in general contain multiple message types.
- **Commitments**. A protocol produces one or more commitments. The commitments (both the signature and the data) must be stored.

Note: Messages are represented as JSON-encoded objects; the transport layer should be able to reliably send and receive such messages.

Note: some data required for signature verification is *not* present in these messages but is deterministically generated by each party. For example, [setNonce](https://github.com/counterfactual/contracts/blob/develop/contracts/NonceRegistry.sol#L42) requires a salt, which is a monotonically increasing counter on the number of applications in a channel.

## Commitments

In our codebase, a `CfOperation` is a class that specifies a commitment type, in other word, a type of transaction. A given `CfOperation` will fix most of the structure of the transaction but accept a small number of parameters (passed into the constructor). Given a `CfOperation` instance, the `hashToSign` function will return a `bytes32` digest that all signatories must sign, and those signatures can be passed into the `transaction` function, to return a transaction.

## Commitment Structrue

- the cryptographic *signature* over some hash representing the transaction to be executed
- the *data* that allows any party in the channel to reconstruct the hash and thus verify the signature

- **Transaction digest**.  The transaction digest is the hash that is signed by each party, enabling the protocol's transaction to be executed on-chain. The calldata, if present, is used to generate the digest.
- **Transaction**. The transaction is the `(to, val, data, op)` tuple that a given protocol allows one to broadcast on-chain. These transactions enforce commitments created from the calldata and signature digests, manifesting the off-chain counterfactual state into the on-chain reality.

## Multisig Creation

Assume there exists a multisig shared by two parties, Alice and Bob.

The state of our GSC looks like this (note everything above the line is "on-chain" and everything below the line is "off-chain"):

![multisig](../img/multisig.png)

With this multisig, we can begin running the Counterfactual Protocols to update our off-chain state.

## List of Protocols

- [Setup](./setup.md)
- [Install](./install.md)
- [Update](./update.md)
- [Uninstall](./uninstall.md)
