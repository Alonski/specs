# Protocol Message Format

## Protocols

A protocol is a series of actions performed by participants that change the state of a GSC. The list of protocols is: setup, install, update, uninstall.

A protocol consists of the following:

- **Handshake**. The protocol handshake is the series of messages exchanged between all parties in the state channel, as well as dependencies between messages. We write the handshake in a table; each message depends on the rows above it (i.e., the sender will not send the message until all the above messages have been sent/received), and each column represents the sender of the message.
- **Message**. A message is the set of information that must be exchanged by the parties to recreate (and validate) the commitment signatures and associated transactions that those signatures enable. Each protocol may in general contain multiple message types.
- **Commitments**. A protocol produces one or more commitments. The commitments (both the signature and the data) must be stored.

Note: Messages are represented as JSON-encoded objects; the transport layer should be able to reliably send and receive such messages.

Note: some data required for signature verification is *not* present in these messages but is deterministically generated by each party. For example, [setNonce](https://github.com/counterfactual/contracts/blob/develop/contracts/NonceRegistry.sol#L42) requires a salt, which is a monotonically increasing counter on the number of applications in a channel.

## Commitments

In our codebase, a `CfOperation` is a class that specifies a commitment type, in other word, a type of transaction. A given `CfOperation` will fix most of the structure of the transaction but accept a small number of parameters (passed into the constructor). Given a `CfOperation` instance, the `hashToSign` function will return a `bytes32` digest that all signatories must sign, and those signatures can be passed into the `transaction` function, to return a transaction.

## Commitment Structrue

- the cryptographic *signature* over some hash representing the transaction to be executed
- the *data* that allows any party in the channel to reconstruct the hash and thus verify the signature

- **Transaction digest**.  The transaction digest is the hash that is signed by each party, enabling the protocol's transaction to be executed on-chain. The calldata, if present, is used to generate the digest.
- **Transaction**. The transaction is the `(to, val, data, op)` tuple that a given protocol allows one to broadcast on-chain. These transactions enforce commitments created from the calldata and signature digests, manifesting the off-chain counterfactual state into the on-chain reality.

## Multisig Creation

Assume there exists a multisig shared by two parties, Alice and Bob.

The state of our GSC looks like this (note everything above the line is "on-chain" and everything below the line is "off-chain"):

![multisig](images/multisig.png)

With this multisig, we can begin running the Counterfactual Protocols to update our off-chain state.

## Setup Protocol

**Discussion:**

The very first protocol every GSC must run is the Setup Protocol. As the name suggests, its purpose is to setup the counterfactual state so that later protocols can execute properly. Specifically, it exchanges a commitment allowing a special type of application to withdraw funds from the multisig. We call this application the Free Balance contract, representating the available funds for any new application to be installed into the GSC.

Completing the Setup Protocol transitions the counterfactual state to

![setup](images/setup.png)

If the Free Balance is ever put on-chain, parties can receive the amounts specified in the Free Balance by broadcasting the **Transaction** enabled by the Setup Protocol. As of right now, there are no funds available for applications in our GSC, and so the Free Balance has a state of 0, 0.

After discussing later protocols, we'll see how the Free Balance is a fundamental accounting mechanism that allows our GSC construction to maintain a *conservation of balances* across state channel applications, so that the sum of all funds in the free balance and all installed applications is equal to the amount of funds deposited in the multisig.

**Handshake:**

|A        |B          |
|-        |-          |
|`Setup`  |           |
|         |`SetupAck` |

**Message:**

```typescript
let Setup = {
  protocol: 0x01,
  multisig: Address,
  data: None,
  from: 0xAlice,
  to: 0xBob,
  seq: 0,
  signature: Signature_Alice,
}
let SetupAck = {
  protocol: 0x01,
  multisig: Address,
  data: None,
  fromAddress: Bob,
  toAddress: Alice,
  seq: 1,
  signature: Signature_Bob,
}
```

Unlike the rest of the protocols, there is no extra message data for the Setup protocol because it is deterministic. It always installs a Free Balance contract with starting balances of 0, and so no extra data is required to be passed in from outside the context of the protocol execution.

**Calldata:**

```typescript
// todo: needs to be a proxyDelegateCall through the reigstry
//       with the withdraw as calldata
//       update once the free balance code is updated
let calldata = new ethers.Interface([
	"withdraw()"
]).functions.setNonce.encode([]);
```

This calldata is expected to be invoked by the multisig's [`execTransaction`](https://github.com/counterfactual/contracts/blob/develop/contracts/MinimumViableMultisig.sol#L55)  in the context of a delegate call, thereby sending funds from the multisig to its rightful owners by inspecting the state of the Free Balance contract and `transfer`ing the funds.

**Signature Digest:**

```typescript
let digest = ethers.utils.solidityKeccak256(
  ["bytes1", "address", "address", "uint256", "bytes", "uint256"],
  [
    "0x19",
	this.multisig,
	REGISTRY, // to (global contract)
	0,        // val
	calldata, // data
	1         // op (delegatecall)
  ]
);
```

Once all parties in the channel have signed the digest, we can invoke the transaction to withdraw the funds at any time. Specifically,

**Transaction:**

```typescript
function multisigExecTransaction(calldata) {
    let to = Setup.multisig;
    let val = 0;
    let data = new ethers.Interface([
        "execTransaction(address,uint256,bytes,uint256,bytes)"
    ]).functions.execTransaction.encode([
        REGISTRY_ADDRESS,  // to
        0,                  // val
        calldata,
        1,                  // delegatecall
        Signature.toBytes(signatures)
    ]);
    let op = call;
    return {
        to, val, data, op
    }
}
let transaction = multisigExecTransaction(calldata);
```

## Install Protocol

(For ease of explanation, assume the multisig is now magically owning 20 ETH and that the Free Balance has recorded a balance of 10, 10 for Alice and Bob. We will explain how depositing is implemented by using the `Install` and `Uninstall` protocols at the end.)

**Discussion:**

The install protocol exchanges a commitment that transfers the ability to withdraw some amount of the multisig's funds from the Free Balance contract to a Conditional Transfer on the particular application being installed.

Specifically, the commitment is a signature enabling a *multi-send* transaction that performs three tasks:

- <a href="#need-to-change-free-bal-contract-to-not-use-cond-transfer">updates the free balance state</a>, decrementing both parties by the amount they contribute to the application install
- <a href="https://github.com/counterfactual/contracts/blob/develop/contracts/NonceRegistry.sol#L42">sets the nonce registry entry to 1</a>, ensuring the "condition" in the Conditional Transfer is true
- <a href="https://github.com/counterfactual/contracts/blob/develop/contracts/delegateTargets/ConditionalTransfer.sol#L34">executes the conditional transfer</a> via delegatecall, withdrawing the funds from the multisig and distributing them according to the state of the application which the conditional transfer points to.

In other words, running the install protocol to play a game of Tic-Tac-Toe where Alice and Bob both bet 1 ETH transitions the counterfactual state to

![install](images/install.png)

Notice how the funds move out of the free balance and into the tic-tac-toe application. As mentioned before, it is an invariant of the system that the sum of both the free balance and all installed applications equals the amount deposited in the multisig.

**Handshake:**

|A|B|
|-|-|
|`Install`||
||`InstallAck`|

**Message:**

```typescript
/**
 * 1,2 refers to the "canonical" order of the peers, i.e., the
 * lexicographic sorted order of addresses.
 */
InstallData = {
  peer1: PeerBalance,  // (address, free_balance_deduction)
  peer2: PeerBalance,
  keyA: Address,       // app-specific ephemeral key
  keyB: Address,
  terms: Terms,        // (asset_type, limit, token_address)
  app: CfAppInterface, // (app_address, reducer_sighash, resolver_sighash,
                       //  turntaker_sighash, is_state_final_sighash)
  timeout: number,
}
Install = {
  protocol: 0x02,
  multisig: Address,
  data: InstallData,
  from: 0xAlice,
  to: 0xBob,
  seq: 0,
  signature: Signature_Alice,
}
InstallAck = {
  protocol: 0x02,
  multisig: Address,
  data: InstallData,
  fromAddress: Bob,
  toAddress: Alice,
  seq: 1,
  signature: Signature_Bob,
}
```

**Calldata:**

```typescript
// first build the individual transactions
let free_balance_update = {
	op: 0, // Call
	to: FREE_BALANCE_ADDRESS,
	val: 0,
	data: // todo: update once we rewrite free balance without cond transfer
}
let set_nonce_registry = {
	op: 0, // Call
	to: NONCE_REGISTRY_ADDRESS,
	val: 0,
	data: new ethers.Interface([Abi.setNonce]).functions.setNonce.encode([
		APP_NUMBER_ID, // k if this application is the kth installed application
		1
	]);
}

// Counterfactual Address of the application, specifically, the
// StateChannel.sol object.
let cfAddress = ethers.utils.solidityKeccak256(
	["bytes1", "bytes", "uint256"],
    ["0x19", StateChannel.initcode, APP_NUMBER_ID]
);
let conditional_transfer = {
	op: 1, // Delegatecall
	to: FREE_BALANCE_ADDRESS,
	val: 0,
	data: new ethers.Interface([
			Abi.executeStateChannelConditionalTransfer
		]).functions.executeStateChannelConditionalTransfer.encode([
			REGISTRY_ADDRESS,
			NONCE_REGISTRY_ADDRESS,
	        APP_NUMBER_ID, // k if this application is the kth installed application
			1,
			cfAddress,
			InstallData.terms
		])
}
let transactions = [free_balance_update, set_nonce_registry, conditional_transfer];

// now construct the multisend
let calldata = () => {
	let txs: string = "0x";
	for (let i = 0; i < transactions.length; i++) {
		txs += ethers.utils.defaultAbiCoder
			.encode(
				["tuple(uint256,address,uint256,bytes)"],
				[
				   	[
				   		transactions[i].op,
			   			transactions[i].to,
		   				transactions[i].val,
	   					transactions[i].data
   					]
				]
			)
		   	.substr(2);
	}
    return txs
}
```

**Signature digest:**

```typescript
let digest = ethers.utils.solidityKeccak256(
  ["bytes1", "address", "address", "uint256", "bytes", "uint256"],
  [
    "0x19",
	this.multisig,
	MULTISEND_ADDRESS, // to (global contract)
	0,                 // val
	calldata,          // data
	1                  // op (delegatecall)
  ]
);
```

**Transaction:**

```typescript
// see Setup for the definition of multisigExecTransaction
let transaction = multisigExecTransaction(calldata);
```

## Update Protocol

**Discussion:**

Once an application has been installed into the GSC, the multisig has transferred control over the installed amount from the free balance to the application's payout function, a mapping from application state to funds distribution. For example, in the case of Tic-Tac-Toe, a possible payout function is: if X wins, Alice gets 2 ETH, else if O wins Bob gets 2 ETH, else send 1 ETH to Alice and Bob.

And so as the underlying state of the application changes, the result of the payout function changes. It is the job of the Update Protocol to mutate this state, independently of the rest of the counterfactual structure.

Using our Tic-Tac-Toe example, if Alice decides to place an X on the board, Alice would run the Update Protocol, transitioning our state to

![update](images/update.png)

Notice how both the board changes and the *local* nonce for the app is bumped from 0 to 1. To play out the game, we can continuously run the update protocol, making one move at a time.

**Handshake:**

| A        | B           |
| -------- | ----------- |
| `Update` |             |
|          | `UpdateAck` |

**Messsage:**

```typescript
UpdateData = {
  appStateHash: H256
}
Update = {
  protocol: 0x03,
  cfAddress: H256, // counterfactual address of the application
  data: UpdateData,
  from: 0xAlice,
  to: 0xBob,
  seq: 0,
  signature: Signature_Alice,
}
UpdateAck = {
  protocol: 0x03,
  cfAddress: H256, // counterfactual address of the application
  data: None,
  fromAddress: Bob,
  toAddress: Alice,
  seq: 1,
  signature: Signature_Bob,
}
```

It's worth pointing out that the `appStateHash` is a hash on an *application-unique* state struct. For example, see our <a href="https://github.com/counterfactual/contracts/blob/develop/contracts/apps/PaymentApp.sol#L9">two party payment</a> example. This hash along with other StateChannel details is used in the following signature digest.

**Signature Digest:**

```typescript
ethers.utils.solidityKeccak256(
	["bytes1", "address[]", "uint256", "uint256", "bytes32"],
	[
		"0x19",                       // required for every sig digest (ERC 191)
		[ALICE_ADDRESS, BOB_ADDRESS], // must be in sorted order
		NONCE,                        // local nonce (1 in the example above)
		TIMEOUT,                      // determined on installation
		APP_STATE_HASH                // given in UpdateData
	]
);
```

When unanimously exchanged, this signature allows us to invoke the <a href="https://github.com/counterfactual/contracts/blob/develop/contracts/StateChannel.sol#L162">setState</a> function on the state channel. Specifically,

**Transaction:**

```typescript
let to = REGISTRY_ADDRESS;
let val = 0;
let data = new ethers.Interface([
    "proxyCall(address,bytes32,bytes)"
]).functions.proxyCall.encode([
	registry,
	appCfAddr,
    new ethers.Interface([
        "setState(bytes32,uint256,uint256,bytes)"
    ]).functions.setState.encode([
		appStateHash,
		appLocalNonce,
		timeout,
		signatures
	])
]);
let op = 0; // CALL
```

This transaction uses the global, on-chain Registry contract to translate the counterfactual address of the application into an on-chain address, and subsequently invoke the `setState` function with the signatures exchanged during the protocol.

## Uninstall Protocol

**Discussion:**

The lifecycle of an application completes when it reaches some type of end or "final" state, at which point both parties know the finalized distribution of funds in the application-specific state channel.

Now, both parties could simply broadcast the application on chain, wait the dispute period, and then broadcast the execution of the Conditional Transfer, thereby paying out the funds on chain. A better solution, however, is to transfer the funds controlled by the application back to the Free Balance contract off chain, so that they could be reused for other applications.

Using our Tic-Tac-Toe example, imagine Alice made the final winning move, declaring X the winner. If Alice runs the Uninstall Protocol, then the Counterfactual state transitions to

![uninstall](images/uninstall.png)

Notice the two operations here:

- <a href="#need-to-change-free-bal-contract-to-not-use-cond-transfer">set a new state</a> on the Free Balance. Alice's balance in the Free Balance object was incremented by 2 ETH, repurposing the funds once owned by the Tic-Tac-Toe application.
- <a href="https://github.com/counterfactual/contracts/blob/develop/contracts/NonceRegistry.sol#L42">set a new nonce</a> on the Nonce Registry. As a result, the Conditional Transfer pointing at Tic-Tac-Toe was invalidated, because we changed its associated entry in the NonceRegistry to 2.

Specifically, when we exchange commitments on the Conditional Transfer in the Install Protocol, we are exchanging signatures allowing us to execute a Conditional Transfer if and only if the nonce equals 1. *If the Nonce is ever not 1*, then the conditional transfer will fail, as desired in the Uninstall Protocol.

**Handshake:**

| A           | B              |
| ----------- | -------------- |
| `Uninstall` |                |
|             | `UninstallAck` |

**Message:**

```typescript
/**
 * As in install, 1 and 2 refer to the canonical, sorted order of the addresses for
 * the peers in the channel.
 */
UninstallData = {
	peer1: PeerBalance, // (address, payout_distribution),
    peer2: PeerBalance, // (address, payout_distrubution)
}
Uninstall = {
  protocol: 0x04,
  cfAddress: H256, // counterfactual address of the application
  data: UpdateData,
  from: 0xAlice,
  to: 0xBob,
  seq: 0,
  signature: Signature_Alice,
}
AckUninstall = {
  protocol: 0x04,
  cfAddress: H256, // counterfactual address of the application
  data: UninstallData,
  fromAddress: Bob,
  toAddress: Alice,
  seq: 1,
  signature: Signature_Bob,
}
```

**Calldata:**

```typescript
// first build the individual transactions

// set state on the free balance, incrementing the balances according to the app payout
let free_balance_update = {
	op: 0, // Call
	to: FREE_BALANCE_ADDRESS,
	val: 0,
	data: // todo after we update free balance to not use a conditional transfer
}
// set the nonce registry entry to 2, invalidating any conditional transfer on the app
let set_nonce_registry = {
	op: 0, // Call
	to: FREE_BALANCE_ADDRESS,
	val: 0,
	data: new ethers.Interface([Abi.setNonce]).functions.setNonce.encode([
			APP_NUMBER_ID, // k if this application is the kth installed application
			2
		]);
}
let transactions = [free_balance_update, set_nonce_registry];

// now construct the multisend
let calldata = // use the transactions to construct calldata (see the install protocol)
```

**Signature digest:**

```typescript
ethers.utils.solidityKeccak256(
  ["bytes1", "address", "address", "uint256", "bytes", "uint256"],
  [
    "0x19",
	this.multisig,
	MULTISEND_ADDRESS, // to (global contract)
	0, // val
	calldata, // data
	0 // op (call)
  ]
);
```

As usual this signature allows us to invoke <a href="https://github.com/counterfactual/contracts/blob/develop/contracts/MinimumViableMultisig.sol">execTransaction</a> on our multisig with the given calldata, which triggers our multisend transaction from above.

**Transaction:**

```typescript
function transaction() {
    let to = MULTISIG_ADDRESS;
    let val = 0;
    let data = new ethers.Interface([
        "execTransaction(address,uint256,bytes,uint256,bytes)"
    ]).functions.execTransaction.encode([
        MULTISEND_ADDRESS, // to
        0, // val
        calldata,
        0, // call
        Signature.toBytes(signatures)
    ]);
    let op = delegatecall;
	return {
    	to, val, data, op
	}
}
```
